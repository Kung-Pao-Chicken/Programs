<p><br/></p><p>一、基础</p><div>1、说明：创建数据库<br/>CREATE DATABASE database-name <br/>2、说明：删除数据库<br/>drop database dbname<br/>3、说明：备份sql server<br/>--- 创建 备份数据的 device<br/>USE master<br/>EXEC sp_addumpdevice &#39;disk&#39;, &#39;testBack&#39;, &#39;c:\mssql7backup\MyNwind_1.dat&#39;<br/>--- 开始 备份<br/>BACKUP DATABASE pubs TO testBack <br/>4、说明：创建新表<br/>create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)<br/>根据已有的表创建新表： <br/>A：create table tab_new like tab_old (使用旧表创建新表)<br/>B：create table tab_new as select col1,col2… from tab_old definition only<br/>5、说明：删除新表<br/>drop table tabname <br/>6、说明：增加一个列<br/>Alter table tabname add column col type<br/>注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。<br/>7、说明：添加主键： Alter table tabname add primary key(col) <br/>说明：删除主键： Alter table tabname drop primary key(col) <br/>8、说明：创建索引：create [unique] index idxname on tabname(col….) <br/>删除索引：drop index idxname<br/>注：索引是不可更改的，想更改必须删除重新建。<br/>9、说明：创建视图：create view viewname as select statement <br/>删除视图：drop view viewname<br/>10、说明：几个简单的基本的sql语句<br/>选择：select * from table1 where 范围<br/>插入：insert into table1(field1,field2) values(value1,value2)<br/>删除：delete from table1 where 范围<br/>更新：update table1 set field1=value1 where 范围<br/>查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!<br/>排序：select * from table1 order by field1,field2 [desc]<br/>总数：select count as totalcount from table1<br/>求和：select sum(field1) as sumvalue from table1<br/>平均：select avg(field1) as avgvalue from table1<br/>最大：select max(field1) as maxvalue from table1<br/>最小：select min(field1) as minvalue from table1<br/>11、说明：几个高级查询运算词<br/>A： UNION 运算符 <br/>UNION
 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 
一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 <br/>B： EXCEPT 运算符 <br/>EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 <br/>C： INTERSECT 运算符<br/>INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 <br/>注：使用运算词的几个查询结果行必须是一致的。 <br/>12、说明：使用外连接 <br/>A、left outer join： <br/>左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。 <br/>SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c<br/>B：right outer join: <br/>右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。<br/>C：full outer join： <br/>全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>二、提升</div><div>1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)<br/>法一：select * into b from a where 1&lt;&gt;1<br/>法二：select top 0 * into b from a</div><div>2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)<br/>insert into b(a, b, c) select d,e,f from b;</div><div>3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)<br/>insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件<br/>例子：..from b in &#39;&quot;&amp;Server.MapPath(&quot;.&quot;)&amp;&quot;\data.mdb&quot; &amp;&quot;&#39; where..</div><div>4、说明：子查询(表名1：a 表名2：b)<br/>select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</div><div>5、说明：显示文章、提交人和最后回复时间<br/>select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b</div><div>6、说明：外连接查询(表名1：a 表名2：b)<br/>select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</div><div>7、说明：在线视图查询(表名1：a )<br/>select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</div><div>8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括<br/>select * from table1 where time between time1 and time2<br/>select a,b,c, from table1 where a not between 数值1 and 数值2</div><div>9、说明：in 的使用方法<br/>select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</div><div>10、说明：两张关联表，删除主表中已经在副表中没有的信息 <br/>delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )</div><div>11、说明：四表联查问题：<br/>select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where .....</div><div>12、说明：日程安排提前五分钟提醒 <br/>SQL: select * from 日程安排 where datediff(&#39;minute&#39;,f开始时间,getdate())&gt;5</div><div>13、说明：一条sql 语句搞定数据库分页<br/>select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段</div><div>14、说明：前10条记录<br/>select top 10 * form table1 where 范围</div><div>15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)<br/>select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)</div><div>16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表<br/>(select a from tableA ) except (select a from tableB) except (select a from tableC)</div><div>17、说明：随机取出10条数据<br/>select top 10 * from tablename order by newid()</div><div>18、说明：随机选择记录<br/>select newid()</div><div>19、说明：删除重复记录<br/>Delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)</div><div>20、说明：列出数据库里所有的表名<br/>select name from sysobjects where type=&#39;U&#39;</div><div>21、说明：列出表里的所有的<br/>select name from syscolumns where id=object_id(&#39;TableName&#39;)</div><div>22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。<br/>select
 type,sum(case vender when &#39;A&#39; then pcs else 0 end),sum(case vender when
 &#39;C&#39; then pcs else 0 end),sum(case vender when &#39;B&#39; then pcs else 0 end) 
FROM tablename group by type<br/>显示结果：<br/>type vender pcs<br/>电脑 A 1<br/>电脑 A 1<br/>光盘 B 2<br/>光盘 A 2<br/>手机 B 3<br/>手机 C 3</div><div>23、说明：初始化表table1</div><div>TRUNCATE TABLE table1</div><div>24、说明：选择从10到15的记录<br/>select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>三、技巧</div><div>1、1=1，1=2的使用，在SQL语句组合时用的较多</div><div>“where 1=1” 是表示选择全部&nbsp;&nbsp; “where 1=2”全部不选，<br/>如：<br/>if @strWhere !=&#39;&#39; <br/>begin<br/>set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;] where &#39; + @strWhere <br/>end<br/>else <br/>begin<br/>set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;]&#39; <br/>end</div><div>我们可以直接写成<br/>set @strSQL = &#39;select count(*) as Total from [&#39; + @tblName + &#39;] where 1=1 安定 &#39;+ @strWhere</div><div>2、收缩数据库<br/>--重建索引<br/>DBCC REINDEX<br/>DBCC INDEXDEFRAG<br/>--收缩数据和日志<br/>DBCC SHRINKDB<br/>DBCC SHRINKFILE</div><div>3、压缩数据库<br/>dbcc shrinkdatabase(dbname)</div><div>4、转移数据库给新用户以已存在用户权限<br/>exec sp_change_users_login &#39;update_one&#39;,&#39;newname&#39;,&#39;oldname&#39;<br/>go</div><div>5、检查备份集<br/>RESTORE VERIFYONLY from disk=&#39;E:\dvbbs.bak&#39;</div><div>6、修复数据库<br/>ALTER DATABASE [dvbbs] SET SINGLE_USER<br/>GO<br/>DBCC CHECKDB(&#39;dvbbs&#39;,repair_allow_data_loss) WITH TABLOCK<br/>GO<br/>ALTER DATABASE [dvbbs] SET MULTI_USER<br/>GO</div><div>7、日志清除<br/>SET NOCOUNT ON<br/>DECLARE @LogicalFileName sysname,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @MaxMinutes INT,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @NewSize INT</div><div><br/>USE&nbsp;&nbsp;&nbsp;&nbsp; tablename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 要操作的数据库名<br/>SELECT @LogicalFileName = &#39;tablename_log&#39;, -- 日志文件名<br/>@MaxMinutes = 10,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Limit on time allowed to wrap log.<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @NewSize = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 你想设定的日志文件的大小(M)</div><div>-- Setup / initialize<br/>DECLARE @OriginalSize int<br/>SELECT @OriginalSize = size <br/>FROM sysfiles<br/>WHERE name = @LogicalFileName<br/>SELECT &#39;Original Size of &#39; + db_name() + &#39; LOG is &#39; + <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONVERT(VARCHAR(30),@OriginalSize) + &#39; 8K pages or &#39; + <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + &#39;MB&#39;<br/>FROM sysfiles<br/>WHERE name = @LogicalFileName<br/>CREATE TABLE DummyTrans<br/>(DummyColumn char (8000) not null)</div><div><br/>DECLARE @Counter&nbsp;&nbsp; INT,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @StartTime DATETIME,<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @TruncLog VARCHAR(255)<br/>SELECT @StartTime = GETDATE(),<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @TruncLog = &#39;BACKUP LOG &#39; + db_name() + &#39; WITH TRUNCATE_ONLY&#39;</div><div>DBCC SHRINKFILE (@LogicalFileName, @NewSize)<br/>EXEC (@TruncLog)<br/>-- Wrap the log if necessary.<br/>WHILE&nbsp;&nbsp;&nbsp;&nbsp; @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName) <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND (@OriginalSize * 8 /1024) &gt; @NewSize <br/>BEGIN -- Outer loop.<br/>&nbsp;&nbsp;&nbsp; SELECT @Counter = 0<br/>&nbsp;&nbsp;&nbsp; WHILE ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BEGIN -- update<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT DummyTrans VALUES (&#39;Fill Log&#39;) <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DELETE DummyTrans<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT @Counter = @Counter + 1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END&nbsp;&nbsp; <br/>&nbsp;&nbsp;&nbsp; EXEC (@TruncLog) <br/>END&nbsp;&nbsp; <br/>SELECT &#39;Final Size of &#39; + db_name() + &#39; LOG is &#39; +<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONVERT(VARCHAR(30),size) + &#39; 8K pages or &#39; + <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONVERT(VARCHAR(30),(size*8/1024)) + &#39;MB&#39;<br/>FROM sysfiles <br/>WHERE name = @LogicalFileName<br/>DROP TABLE DummyTrans<br/>SET NOCOUNT OFF</div><div>8、说明：更改某个表<br/>exec sp_changeobjectowner &#39;tablename&#39;,&#39;dbo&#39;</div><div>9、存储更改全部表</div><div>CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch<br/>@OldOwner as NVARCHAR(128),<br/>@NewOwner as NVARCHAR(128)<br/>AS</div><div>DECLARE @Name&nbsp;&nbsp; as NVARCHAR(128)<br/>DECLARE @Owner as NVARCHAR(128)<br/>DECLARE @OwnerName as NVARCHAR(128)</div><div>DECLARE curObject CURSOR FOR <br/>select &#39;Name&#39;&nbsp;&nbsp; = name,<br/>&#39;Owner&#39;&nbsp;&nbsp; = user_name(uid)<br/>from sysobjects<br/>where user_name(uid)=@OldOwner<br/>order by name</div><div>OPEN curObject<br/>FETCH NEXT FROM curObject INTO @Name, @Owner<br/>WHILE(@@FETCH_STATUS=0)<br/>BEGIN&nbsp;&nbsp;&nbsp;&nbsp; <br/>if @Owner=@OldOwner <br/>begin<br/>set @OwnerName = @OldOwner + &#39;.&#39; + rtrim(@Name)<br/>exec sp_changeobjectowner @OwnerName, @NewOwner<br/>end<br/>-- select @name,@NewOwner,@OldOwner</div><div>FETCH NEXT FROM curObject INTO @Name, @Owner<br/>END</div><div>close curObject<br/>deallocate curObject<br/>GO</div><div><br/>10、SQL SERVER中直接循环写入数据<br/>declare @i int<br/>set @i=1<br/>while @i&lt;30<br/>begin<br/>&nbsp;&nbsp; insert into test (userid) values(@i)<br/>&nbsp;&nbsp; set @i=@i+1<br/><p>end</p><p><br/></p><!--30<br--></div><script></script>