<div id="cnblogs_post_body"><p><span style="font-size: 18px;"><strong><span style="color: #ff0000;">一、泛型入门：</span></strong></span></p><p>我们先来看一个最为常见的泛型类型List&lt;T&gt;的定义<br/><span style="line-height: 1.5;">(真正的定义比这个要复杂的多，我这里删掉了很多东西)</span></p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre><span style="color: #000000;">[Serializable]</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;<span style="color: #000000;">{ &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> T <span style="color: #0000ff;">this</span>[<span style="color: #0000ff;">int</span> index] { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; } &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Add(T item); &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Clear(); &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">bool</span><span style="color: #000000;"> Contains(T item); &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> IndexOf(T item); &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">bool</span><span style="color: #000000;"> Remove(T item); &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Sort(); &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> T[] ToArray();
}</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p>List后面紧跟着一个&lt;T&gt;表示它操作的是一个未指定的数据类型<br/>（T代表着一个未指定的数据类型）</p><p>可以把T看作一个变量名，T代表着一个类型，<br/>在List&lt;T&gt;的源代码中任何地方都能使用T</p><p>T被用作方法的参数和返回值<br/>Add方法接收T类型的参数，ToArray方法返回一个T类型的数组</p><p><strong>注意：</strong></p><p>&amp;#12288;&amp;#12288;泛型参数应该以T开头，要么就叫T，要么就叫TKey、TValue之类的；<br/>&amp;#12288;&amp;#12288;这跟接口要以I开头是一样的，这是约定。</p><p>下面来看一段使用泛型类型的代码</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre>            <span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">();
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a.Add(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a.Add(</span><span style="color: #800080;">2</span><span style="color: #000000;">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #008000;">//</span><span style="color: #008000;">这是错误的，因为你已经指定了泛型类型为int，就不能在这个容器中放入其他的值 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #008000;">//</span><span style="color: #008000;">这是编译器错误，更提升了排错效率，如果是运行期错误，不知道要多么烦人</span>
            a.Add(<span style="color: #800000;">&quot;</span><span style="color: #800000;">3</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">var</span> item = a[<span style="color: #800080;">2</span>];</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p>请注意上面代码里的注释</p><p><span style="font-size: 18px;"><strong><span style="color: #ff0000;">二、泛型的作用(1)：</span></strong></span></p><p><span style="line-height: 1.5;">作为程序员，写代码时刻不忘代码重用。<br/>代码重用可以分成很多类，其中<strong>算法重用</strong>就是非常重要的一类</span></p><p><span style="line-height: 1.5;">假设你要为一组整型数据写一个排序算法，又要为一组浮点型数据写一个排序算法<br/>如果没有泛型类型，你会怎么做呢？</span></p><p><span style="line-height: 1.5;">你可能想到了方法的重载<br/>写两个同名方法，一个方法接收整型数组，另一个方法接收浮点型的数组</span></p><p><span style="line-height: 1.5;">但有了泛型，你就完全不必这么做，只要设计一个方法就够用了，你甚至可以用这个方法为一组字符串数据排序</span></p><p><span style="font-size: 18px;"><strong><span style="line-height: 1.5; color: #ff0000;">三、泛型的作用(2)：</span></strong></span></p><p>假设你是一个方法的设计者，<br/>这个方法需要有一个输入参数，但你并能确定这个输入参数的类型<br/>那么你会怎么做呢？<br/><br/>有一部分人可能会马上反驳：“不可能有这种时候！”<br/>那么我会跟你说，编程是一门经验型的工作，你的经验还不够，还没有碰到过类似的地方。</p><p>另一部分人可能考虑把这个参数的类型设置成Object的<br/>这确实是一种可行的方案<br/>但会造成下面两个问题<br/><br/>如果我给这个方法传递整形的数据<br/>（值类型的数据都一样）<br/>就会产生额外的装箱、拆箱操作<br/>造成<strong>性能损耗</strong><br/><br/>如果你这个方法里的处理逻辑不适用于字符串的参数<br/>而使用者又传了一个字符串进来<br/>编译器是不会报错的，<br/>只有在运行期才会报错<br/>(如果质管部门没有测出这个运行期BUG，那么不知道要造成多大的损失呢)<br/>这就是我们常说的：<strong>类型不安全</strong></p><p><span style="color: #ff0000; font-size: 18px;"><strong>四、泛型的示例：</strong></span></p><p>像List&lt;T&gt;和Dictionary&lt;TKey,TValue&gt;之类的泛型类型我们经常用到<br/>下面我介绍几个不常用到的泛型类型<br/><br/>ObservableCollection&lt;T&gt;<br/>当这个集合发生改变后会有相应的事件得到通知<br/>请看如下代码：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
{ &nbsp; &nbsp;</span><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span> ObservableCollection&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">();
 &nbsp; &nbsp;a.CollectionChanged </span>+=<span style="color: #000000;"> a_CollectionChanged;
}</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> a_CollectionChanged(<span style="color: #0000ff;">object</span><span style="color: #000000;"> sender, NotifyCollectionChangedEventArgs e)
{ &nbsp; &nbsp;</span><span style="color: #008000;">//</span><span style="color: #008000;">可以通过Action来判断是什么操作触发了事件 &nbsp; &nbsp;</span><span style="color: #008000;">//</span><span style="color: #008000;">e.Action == NotifyCollectionChangedAction.Add &nbsp; &nbsp;</span><span style="color: #008000;">//</span><span style="color: #008000;">可以根据以下两个属性来得到更改前和更改后的内容 &nbsp; &nbsp;</span><span style="color: #008000;">//</span><span style="color: #008000;">e.NewItems; &nbsp; &nbsp;</span><span style="color: #008000;">//</span><span style="color: #008000;">e.OldItems;</span>}</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p>使用这个集合需要引用如下两个名称空间</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">using</span><span style="color: #000000;"> System.Collections.ObjectModel;</span><span style="color: #0000ff;">using</span> System.Collections.Specialized;</pre></div><p>&nbsp;</p><p>BlockingCollection&lt;int&gt;是线程安全的集合<br/>来看看下面这段代码</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre><span style="color: #0000ff;">var</span> bcollec = <span style="color: #0000ff;">new</span> BlockingCollection&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #800080;">2</span><span style="color: #000000;">);</span><span style="color: #008000;">//</span><span style="color: #008000;">试图添加1-50</span>Task.Run(() =&gt;<span style="color: #000000;">{ &nbsp; &nbsp;</span><span style="color: #008000;">//</span><span style="color: #008000;">并行循环</span>
    Parallel.For(<span style="color: #800080;">1</span>, <span style="color: #800080;">51</span>, i =&gt;<span style="color: #000000;">
 &nbsp; &nbsp;{
 &nbsp; &nbsp; &nbsp; &nbsp;bcollec.Add(i);
 &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">加入：</span><span style="color: #800000;">&quot;</span> +<span style="color: #000000;"> i);
 &nbsp; &nbsp;});
});

Thread.Sleep(</span><span style="color: #800080;">1000</span><span style="color: #000000;">);
Console.WriteLine(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">调用一次Take</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">);
bcollec.Take();</span><span style="color: #008000;">//</span><span style="color: #008000;">等待无限长时间</span>Thread.Sleep(Timeout.Infinite);</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p>输出结果为：</p><div class="cnblogs_code"><pre>加入：<span style="color: #800080;">1</span><span style="color: #000000;">加入：</span><span style="color: #800080;">37</span><span style="color: #000000;">调用一次Take
加入：</span><span style="color: #800080;">13</span></pre></div><p><span style="line-height: 1.5;">BlockingCollection&lt;int&gt;还可以设置CompleteAdding和IsCompleted属性来拒绝加入新元素<br/>.NET类库还提供了很多的泛型类型，在这里就不一一例举了</span></p><p><span style="color: #ff0000; font-size: 18px;"><strong>五、泛型的继承：</strong></span></p><p>在.net中一切都继承自Object<br/>泛型也不例外<br/>泛型类型可以继承自其他类型<br/>来看一下如下代码</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyType
{ &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> getOneStr()
 &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">return</span> <span style="color: #800000;">&quot;</span><span style="color: #800000;">base object Str</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;
 &nbsp; &nbsp;}
}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyOtherType&lt;T&gt;<span style="color: #000000;"> : MyType
{ &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> getOneStr()
 &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">typeof</span><span style="color: #000000;">(T).ToString();
 &nbsp; &nbsp;}
}</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
{ &nbsp; &nbsp;</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
 &nbsp; &nbsp;{
 &nbsp; &nbsp; &nbsp; &nbsp;MyType target </span>= <span style="color: #0000ff;">new</span> MyOtherType&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">();
 &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(target.getOneStr());
 &nbsp; &nbsp; &nbsp; &nbsp;Console.ReadKey();
 &nbsp; &nbsp;}
}</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p><span style="line-height: 1.5;">泛型类型MyOtherType&lt;T&gt;成功的重写了非泛型类型MyType的方法<br/></span><span style="line-height: 1.5;">如果我试图按如下方式从MyOtherType&lt;T&gt;类型派生子类型</span><span style="line-height: 1.5;">就会导致编译器错误</span></p><div class="cnblogs_code"><pre><span style="color: #008000;">//</span><span style="color: #008000;">编译期错误</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyThirdType : MyOtherType&lt;T&gt;<span style="color: #000000;">{
}</span></pre></div><p>但是如果写成这种方式，就不会出错</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyThirdType : MyOtherType&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">
 &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> getOneStr()
 &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">return</span> <span style="color: #800000;">&quot;</span><span style="color: #800000;">MyThirdType</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;}</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p><span style="line-height: 1.5;">如果一个方法接收MyThirdType类型的参数，<br/></span>那么不能将一个MyOtherType&lt;int&gt;的实例传递给这个方法<br/>然而一个方法如果接收MyOtherType&lt;int&gt;类型的参数<br/>却可以把MyThirdType类型的实例传递给这个方法<br/>写成如下方式也不会出错</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyThirdType&lt;T&gt; : MyOtherType&lt;T&gt;<span style="color: #000000;">
 &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> getOneStr()
 &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">typeof</span>(T).ToString() + <span style="color: #800000;">&quot;</span><span style="color: #800000;"> from MyThirdType</span><span style="color: #800000;">&quot;</span><span style="color: #000000;">;
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;}</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p>此中诀窍，只可意会，不可言传</p><p><span style="font-size: 18px;"><strong><span style="color: #ff0000;">六、泛型接口</span></strong></span></p><p>.NET类库里有很多泛型的接口<br/>比如：IEnumerator&lt;T&gt;、IList&lt;T&gt;等<br/>这里不对这些接口做详细描述了<br/>值说说为什么要有泛型接口。</p><p>其实泛型接口出现的原因和泛型出现的原因类似<br/>拿IComparable这个接口来说，<br/>此接口只描述了一个方法：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> CompareTo(<span style="color: #0000ff;">object</span> obj);</pre></div><p>大家看到，如果是值类型的参数，势必会导致装箱和拆箱操作<br/>同时，也不是强类型的，不能在编译期确定参数的类型<br/>有了IComparable&lt;T&gt;就解决掉这个问题了</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">int</span> CompareTo(T other);</pre></div><p><span style="font-size: 18px;"><strong><span style="color: #ff0000;">七、泛型委托</span></strong></span></p><p>委托描述方法，<br/>泛型委托的由来和泛型接口类似<br/><br/>定义一个泛型委托也比较简单：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">void</span> MyAction&lt;T&gt;(T obj);</pre></div><p>这个委托描述一类方法<br/>这类方法接收T类型的参数，没有返回值<br/>来看看使用这个委托的方法</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">void</span> MyAction&lt;T&gt;<span style="color: #000000;">(T obj);</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
{ &nbsp; &nbsp;</span><span style="color: #0000ff;">var</span> method = <span style="color: #0000ff;">new</span> MyAction&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">(printInt);
 &nbsp; &nbsp;method(</span><span style="color: #800080;">3</span><span style="color: #000000;">);
 &nbsp; &nbsp;Console.ReadKey();
}</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> printInt(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i)
{
 &nbsp; &nbsp;Console.WriteLine(i);
}</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p>由于定义委托比较繁琐<br/>.NET类库在System名称空间，下定义了三种比较常用的泛型委托</p><p>Predicate&lt;T&gt;委托：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">bool</span> Predicate&lt;T&gt;(T obj);</pre></div><p>这个委托描述的方法为接收一个T类型的参数，返回一个BOOL类型的值，一般用于比较方法</p><p>Action&lt;T&gt;委托</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">void</span> Action&lt;T&gt;(T obj);</pre></div><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">void</span> Action&lt;T1, T2&gt;(T1 arg1, T2 arg2);</pre></div><p>这个委托描述的方法，接收一个或多个T类型的参数（最多16个，我这里只写了两种类型的定义方式），没有返回值</p><p>Func&lt;T&gt;委托</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> TResult Func&lt;TResult&gt;();</pre></div><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> TResult Func&lt;T, TResult&gt;(T arg);</pre></div><p>这个委托描述的方法，接收零个或多个T类型的参数（最多16个，我这里只写了两种类型的定义方式），<br/>与Action委托不同的是，它有一个返回值，返回值的类型为TResult类型的</p><p>关于委托的描述，您还可以看我这篇文章<br/><a href="http://www.cnblogs.com/liulun/archive/2013/02/26/2909985.html">30分钟LINQ教程</a></p><p><span style="font-size: 18px;"><strong><span style="color: #ff0000;">八、泛型方法</span></strong></span></p><p>泛型类型中的T可以用在这个类型的任何地方<br/>然而有些时候，我们不希望在使用类型的时候就指定T的类型<br/>我们希望在使用这个类型的方法时，再指定T的类型<br/>来看看如下代码：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyClass
 &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> TParam CompareTo&lt;TParam&gt;<span style="color: #000000;">(TParam other)
 &nbsp; &nbsp; &nbsp; &nbsp;{
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(other.ToString()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> other;
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;}</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p><span style="line-height: 1.5;">上面的代码中MyClass并不是一个泛型类型<br/></span><span style="line-height: 1.5;">但这个类型中的CompareTo&lt;TParam&gt;()却是一个泛型方法<br/></span>TParam可以用在这个方法中的任何地方。</p><p>使用泛型方法一般用如下代码就可以了：</p><div class="cnblogs_code"><pre>obj.CompareTo&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #800080;">4</span><span style="color: #000000;">);
obj.CompareTo</span>&lt;<span style="color: #0000ff;">string</span>&gt;(<span style="color: #800000;">&quot;</span><span style="color: #800000;">ddd</span><span style="color: #800000;">&quot;</span>);</pre></div><p>然而，你可以写的更简单一些，写成如下的方式</p><div class="cnblogs_code"><pre>obj.CompareTo(<span style="color: #800080;">2</span><span style="color: #000000;">);
obj.CompareTo(</span><span style="color: #800000;">&quot;</span><span style="color: #800000;">123</span><span style="color: #800000;">&quot;</span>);</pre></div><p>有人会问：“这不可能，没有指定CompareTo方法的TParam类型，肯定会编译出错的”<br/>我告诉你：不会的，编译器可以帮你完成<strong>类型推断</strong>的工作。<br/><br/><strong>注意：</strong><br/>如果你为一个方法指定了两个泛型参数，而且这两个参数的类型都是T，<br/>那么如果你想使用类型推断，你必须传递两个相同类型的参数给这个方法<br/>不能一个参数用string类型，另一个用object类型，这会导致编译错误。</p><p><span style="font-size: 18px;"><strong><span style="color: #ff0000;">九、泛型约束</span></strong></span></p><p>我们设计了一个泛型类型<br/>很多时候，我们不希望使用者传入任意类型的参数<br/>也就是说，我们希望“约束”一下T的类型<br/>来看看如下代码：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyClass&lt;T&gt; <span style="color: #0000ff;">where</span> T : IComparable&lt;T&gt;<span style="color: #000000;">
 &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> CompareTo(T other)
 &nbsp; &nbsp; &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
 &nbsp; &nbsp; &nbsp; &nbsp;}
 &nbsp; &nbsp;}</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p>上面的代码要求T类型必须实现了IComparable&lt;T&gt;接口<br/>如你所见：泛型的约束通过关键字where来实现。</p><p>泛型方法当然也可以通过类似的方式对泛型参数进行约束<br/>请看如下代码：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyClass
{ &nbsp; &nbsp;</span><span style="color: #0000ff;">public</span> TParam CompareTo&lt;TParam&gt;(TParam other) <span style="color: #0000ff;">where</span> TParam:<span style="color: #0000ff;">class</span><span style="color: #000000;">
 &nbsp; &nbsp;{
 &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(other.ToString()); &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> other;
 &nbsp; &nbsp;}
}</span></pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码" onclick="copyCnblogsCode(this)" href="http://javascript:void(0);"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"/></a></span></div></div><p>上面代码中用了class关键字约束泛型参数TParam；具体稍后解释。</p><p><strong>注意1：</strong><br/>如果我有一个类型也定义为MyClass&lt;T&gt;但没有做约束，<br/>那么这个时候，做过约束的MyClass&lt;T&gt;将与没做约束的MyClass&lt;T&gt;冲突，编译无法通过<strong><br/><br/>注意2：</strong><br/>当你重写一个泛型方法时，如果这个方法指定了约束<br/>在重写这个方法时，不能再指定约束了<strong><br/><br/>注意3：</strong><br/>虽然我上面的例子写的是接口约束，但你完全可以写一个类型，比如说BaseClass<br/>而且，只要是继承自BaseClass的类型都可以当作T类型使用，你不要试图约束T为Object类型，编译不会通过的。（傻子才这么干）<strong><br/><br/>注意4：</strong><br/>有两个特殊的约束：class和struct。<br/>where T : class &nbsp; 约束T类型必须为引用类型<br/>where T : struct &nbsp;约束T类型必须为值类型<strong><br/><br/>注意5：<br/></strong>如果你没有对T进行class约束，<br/>那么你不能写这样的代码：T obj = null; &nbsp;这无法通过编译，因为T有可能是值类型的。<br/>如果你没有对T进行struct约束，也没有对T进行new约束<br/>那么你不能写这样的代码：T obj = new T(); &nbsp;这无法通过编译，因为值类型肯定有无参数构造器，而引用类型就不一定了。<br/>如果你对T进行了new约束：where T : new(); &nbsp;那么new T()就是正确的，因为new约束要求T类型有一个公共无参构造器。<br/><br/><strong>注意6：<br/></strong>就算没有对T进行任何约束，也有一个办法来处理值类型和引用类型的问题<br/>T temp = default(T);<br/>如果T为引用类型，那么temp就是null；如果T为值类型，那么temp就是0；</p><p><strong>注意7：<br/></strong>试图对T类型的变量进行强制转化，一般情况下会报编译期错误。<br/>但你可以先把T转化成object再把object转化成你要的类型（一般不推荐这么做，你应该考虑把T转化成一个约束兼容的类型）<br/>你也可以考虑用as操作符进行类型转化，这一般不会报错，但只能转化成引用类型。</p><p>关于泛型约束的内容，我在这篇文章里也有提到<br/><a href="http://www.cnblogs.com/liulun/archive/2013/02/26/2909985.html">30分钟linq教程</a></p><p><span style="font-size: 18px;"><strong><span style="color: #ff0000;">十、逆变和协变</span></strong></span></p><p>&nbsp;一般情况下，我们使用泛型时，由T标记的泛型类型是不能更改的<br/>也就是说,如下两种写法都是错误的</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">object</span>&gt;<span style="color: #000000;">();
List</span>&lt;<span style="color: #0000ff;">string</span>&gt; b =<span style="color: #000000;"> a;</span><span style="color: #0000ff;">var</span> c = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
List</span>&lt;<span style="color: #0000ff;">object</span>&gt; d = c;</pre></div><p>注意：这里没有写强制转换，即使写了强制转换也是错误的，编译就无法通过</p><p>然而泛型提供了逆变和协变的特性，<br/>有了这两种特性，这种转换就成为了可能。</p><p><strong>逆变：</strong><br/>泛型类型T可以从基类型更改为该类的派生类型，<br/><span style="line-height: 1.5;">用in关键字标记逆变形式的类型参数，<br/>而且这个参数一般作输入参数。</span></p><p><strong>协变：</strong><br/>泛型类型T可以从派生类型更改为它的基类型，<br/>用out关键字来标记协变形式的类型参数，<br/>而且这个参数一般作为返回值</p><p>如果我们定义了一个这样的委托：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> TResult MyAction&lt;<span style="color: #0000ff;">in</span> T,<span style="color: #0000ff;">out</span> TResult&gt;(T obj);</pre></div><p>那么，就可以让如下代码通过编译（不用强制转换）</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">var</span> a = <span style="color: #0000ff;">new</span> MyAction&lt;<span style="color: #0000ff;">object</span>, ArgumentException&gt;(o =&gt; <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArgumentException(o.ToString()));
MyAction</span>&lt;<span style="color: #0000ff;">string</span>, Exception&gt; b = a;</pre></div><p>这就是逆变和协变的威力。</p><p><strong>注意：</strong><br/>只有接口和委托的泛型类型才可以使用逆变和协变的特性</p><p>&nbsp;</p><p>&nbsp;</p></div>